"""
Задание состоит из двух частей.
1 часть – написать программу в соответствии со своим вариантом задания.
 Написать 2 варианта формирования (алгоритмический и с помощью функций Питона), сравнив по времени их выполнение.
2 часть – усложнить написанную программу, введя по своему усмотрению в условие минимум одно ограничение
 на характеристики объектов (которое будет сокращать количество переборов)  и целевую функцию для нахождения оптимального  решения.

ВАРИАНТ №15

Ассортимент магазина составляют  товары К артикулов (названий).
 Допускается к празднику на артикулы товаров (количество от Т до N) установить скидки.
 Сформировать все возможные варианты списков товаров для скидок. """


import time
import itertools
t = 2
n = 1
k = 0
k = int ( input ( "Введите количество товаров К= " ) )
combi=[]


""" ______________________________________________________________
    ||             первая часть через библиотеку               ||
    ||                                                         ||
    --------------------------------------------------------------"""


while t > n: #фильтрация т и n

    t = int ( input ( "\nНужно ввести диапазон товаров Введите от Т до N\n\n Введите Т " ) )
    n = int ( input( "\nВведите N " ) )

y = t
start=time.time()

while   y <= n: #идем от меньшего к большему

    for i in range(0, k): #добовляем числа по размеру списка определяемого y
        if len(combi) >= y:
            break
        else:
            combi.append(i)

    print(f'\n {combi}') #выводим первую комбинацию
    combi.append( k ) #нужны для определения момента выхода из цикла
    combi.append( 0 )

    while True:


        for i in range( len(combi) - 1 ):
            if combi[i] + 1 == combi[i + 1]: #если следующий элемент= предидущий + 1 то идем дальше присаваивая предидущиму значение его индекса

                combi[i] = i

            else:

                break

        if i < y: #если индекс элемента меньше размера комбинации то выводим комбинацю

            combi[i] += 1
            print(f"\n {combi[:-2]}")

        else:

            y += 1
            combi.clear()
            break


end = time.time()
print(f'\nВремя выполнения самописной функции {end-start}')


""" ______________________________________________________________
    ||              вторая часть через библиотеку               ||
    ||                                                          ||
    --------------------------------------------------------------"""



start=time.time()


print("\n\nвторая часть через библиотеку itertools\n\n")
combi=[i for i in range(0,k) ]


for g in range(t,n+1):

    tmp=itertools.combinations(combi,g)
    print(f'\n{list(tmp)},\n комбинций из {g} элементов')

end = time.time()
print(f'\nВремя выполнения питон функции {end-start}')


""" ___________________________________________________________________________________________
    || по новому условию функция работает только с четными размерами комбинаций               ||
    ||                                                                                        ||
    -------------------------------------------------------------------------------------------"""

pause=input("\n\n\nпо новому условию функция работает только с четными размерами комбинаций \n\nДЛЯ ПРОДОЛЖЕНИЯ ВВЕДИТЕ ЛЮБОЙ СИМВОЛ")
y = t
start=time.time()

while   y <= n: #идем от меньшего к большему

    for i in range(0, k): #добовляем числа по размеру списка определяемого y
        if len(combi) >= y and y % 2 == 0:
            break
            print(f'\n первая комбинация из {y} элементов {combi}')  # выводим первую комбинацию
        else:
            combi.append(i)


    combi.append( k ) #нужны для определения момента выхода из цикла
    combi.append( 0 )

    while True:


        for i in range( len(combi) - 1 ):
            if combi[i] + 1 == combi[i + 1]: #если следующий элемент= предидущий + 1 то идем дальше присаваивая предидущиму значение его индекса

                combi[i] = i

            else:

                break

        if i < y : #если индекс элемента меньше размера комбинации то выводим комбинацю

            combi[i] += 1
            print(f"\n {combi[:-2]}")

        else:

            y += 1
            combi.clear()
            break


end = time.time()
print(f'\nВремя выполнения самописной функции {end-start}')



start=time.time()


print("\n\nТЕПЕРЬ  через библиотеку itertools\n\n")
combi=[i for i in range(0,k) ]


for g in range(t,n+1):
    if g % 2 == 0:

        tmp=itertools.combinations(combi,g)
        print(f'\n{list(tmp)},\n комбинций из {g} элементов')
    else:

        continue
end = time.time()
print(f'\nВремя выполнения питон функции {end-start}')
